1.假设R[ax] =FFFAH，R[bx] =FFF0H，则执行指令“add %bx， %ax”后:
AX、BX中的内容各是什么？
标志CF、OF、ZF、SF各是什么？
要求分别将操作数作为无符号数和带符号整数来解释并验证指令执行结果。

解：指令“add  %bx， %ax”的功能是R[ax] ←R[ax]+R[bx]，指令的执行在整数加减运算器中进行，执行结果在AX
	R[ax] =FFFAH+FFF0H=(1)FFEAH
	R[bx] =FFF0H
    标志CF=1，SF=1，OF=0，ZF=0
若作为无符号数来解释，则根据CF=1可判断其结果溢出；
若作为带符号整数来解释，则根据OF=0可判断其结果不溢出且和为-22。

无符号数加法运算结果验证：
R[ax] =FFFAH，即值为65 530
R[bx] =FFF0H，即值为65 520
65 530十65 520=131 050
结果大于16位最大可表示的无符号数65 535，结果溢出，验证正确。
带符号整数加法运算结果验证：
R[ax] =FFFAH，即值为-110B=-6
R[bx] =FFF0H．即值为-10000B=-16
结果为6+（-16）=-22，验证正确。

2.假设R[eax] =000000B4H，R[ebx]=00000011H，M[000000F8H] =000000A0H，请问：
    (1)执行指令“mulb %bl”后，哪些寄存器的内容会发生变化？是否与执行“imulb %bl”指令所发生的变化一样？为什么？请用该例给出的数据验证你的结论。
    (2)执行指令“imull $-16，(%eax，%ebx，4)，%eax”后哪些寄存器和存储单元发生了变化？乘积的机器数和真值各是多少？

解：因为R [eax] =000000B4H，R[ebx] =00000011H，所以，R[al]=B4H，R[bl]=11H。
指令“mulb %bl”中指出的操作数为8位，故指令的功能为“R[ax] =R[al]×R[bl]”，因此，改变内容的寄存器是AX，指令执行后R[ax] =0BF4H，即十进制数3060。
执行指令“imulb %bl”后，R[ax] =FAF4H，即十进制数 -1292。
两条指令执行后发生变化的寄存器都是AX，但是存入AX的内容不一样。
mulb指令执行的无符号数乘法，而imulb执行的是带符号整数乘法，
根据2.7.5节中给出的无符号数和带符号整数的乘法运算规则可知，若乘积只取低8位，则两者的机器数一样，在此例中两者都是F4H;若乘积取16位，则高8位可能不同，此例中一个是0BH，一个是FAH。
验证：此例中mulb指令执行的运算是180×17=3060，而imul指令执行的运算是-76X 17=-1292。
(2)指令“imull $-16，(%eax，%ebx，4)，%eax”
功能:“R[eax] ← (-16)×M[R[eax]+4×R[ebx]”
第二个乘数所在的存储单元地址为
     R[eax]+4*R[ebx] =0xB4+ (0x11<<2) =0xF8=000000F8H
因为M[000000F8H]=000000A0H，与-16相乘后得到一个负的乘积，因此乘积的符号为负，乘积数值部分绝对值的机器数为000000A0H<<4=00000A00H，
对其各位取反末位加1，得到乘积的机器数为FFFFF600H，
指令执行后EAX中存放的内容为FFFFF600H，其真值为-2560。
