1. 假设P为调用过程，Q为被调用过程，程序在IA-32处理器上执行，以下有关过程调用的叙述中，错误的是（ ）。
A. C语言程序中的函数调用就是过程调用
B. 从P传到Q的实参无需重新分配空间存放
C. 从P跳转到Q执行应使用CALL指令
D. 从Q跳回到P执行应使用RET指令

2. 假设P为调用过程，Q为被调用过程，程序在IA-32处理器上执行，以下是C语言程序中过程调用所涉及的操作：
① 过程Q保存P的现场，并为非静态局部变量分配空间
② 过程P将实参存放到Q能访问到的地方
③ 过程P将返回地址存放到特定处，并跳转到Q执行
④ 过程Q取出返回地址，并跳转回到过程P执行
⑤ 过程Q恢复P的现场，并释放局部变量所占空间
⑥ 执行过程Q的函数体
过程调用的正确执行步骤是（ ）。
A. ②→③→④→①→⑤→⑥
B. ②→③→①→④→⑥→⑤
C. ②→③→①→⑥→⑤→④
D. ②→③→①→⑤→⑥→④

3. 以下是有关IA-32/Linux（GCC）的过程调用的叙述，错误的是（ ）
A. 在过程中通常先使用被调用者保存寄存器
B. 每个非叶子过程都有一个栈帧，其大小为16B的倍数
C. EBP寄存器中的内容指向对应栈帧（stack frame）的底部
D. 每个栈帧底部单元中存放其调用过程的EBP内容

4. 以下是有关IA-32/Linux的过程调用的叙述，错误的是（ ）。
A. 每进行一次过程调用，用户栈从高地址向低地址增长出一个栈帧
B. 从被调用过程返回调用过程之前，被调用过程会释放自己的栈帧
C. 只能通过将栈指针ESP作为基址寄存器来访问用户栈中的数据
D. 过程嵌套调用深度越深，栈中栈帧个数越多，严重时会发生栈溢出

5. 以下是有关C程序的变量作用域和生存期的叙述，错误的是（ ）。
A. 静态（static型）变量和非静态局部变量都分配在对应栈帧中
B. 因为非静态局部变量被分配在栈中，所以其作用域仅在过程体内
C. 非静态局部变量可以与全局变量同名，因为它们被分配在不同存储区
D. 不同函数中非静态局部变量可以同名，因为它们被分配在不同栈帧中

6. 以下有关递归过程调用的叙述中，错误的是（ ）。
A. 每次递归调用都会额外执行多条指令，因而时间开销大
B. 每次递归调用都会生成一个新的栈帧，因而空间开销大
C. 每次递归调用在栈帧中保存的返回地址都不相同
D. 递归过程第一个参数的有效地址为R[ebp]+8

7. 以下是一个C语言程序代码：
int add(int x, int y) {
    return x + y;
}

int caller() {
    int t1 = 100;
    int t2 = 200;
    int sum = add(t1, t2);
    return sum;
}
以下关于上述程序代码在 IA-32上执行情况的叙述中，错误的是（ ）。
A. 变量t1、t2和sum被分配在寄存器或caller函数的栈帧中
B. 传递参数时t2和t1的值从高地址到低地址依次存入栈中
C. 入口参数t1和t2的值被分配在add函数的栈帧中
D. add函数返回时返回值存放在EAX寄存器中